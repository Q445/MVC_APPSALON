Debemos de crear un archivo llamado ".env" que son variables de entorno, que nos ayudara a ocultar los datos de una forma "elegante" para que no todos tengan acceso a una informacion delicada por decirlo asi.

Las variables de entorno en PHP se utilizan principalmente para personalizar y automatizar el comportamiento de aplicaciones y scripts, permitiendo que se adapten a diferentes entornos como desarrollo, pruebas o producción sin modificar el código fuente.
Esta práctica es especialmente útil para almacenar información sensible como credenciales de bases de datos, claves de API, o configuraciones específicas de cada entorno, manteniendo estos datos fuera del código y evitando su exposición en repositorios de control de versiones.

En la carpeta includes, vamos a crear un archivo 
.env 

Pero debemos de instalar la dependencia de composer.json:
-> composer require vlucas/phpdotenv  

Las credenciales de la base de datos la vamos a tomar y modificar: 

DB_HOST = localhost
DB_USER = root 
DB_PASS = 1234
DB_NAME = AppSalon

Debemos de configurar el archvio de "app.php"

<?php

use Dotenv\Dotenv;
use Model\ActiveRecord;

require __DIR__ . '/../vendor/autoload.php';
$dotenv = Dotenv::createImmutable(__DIR__); -> A diferencia con el profesor, ahora lo debemos de colocar asi, para evitar los errores, ya que ahora hay una correcion de problemas.

$dotenv->safeload();

require 'funciones.php';
require 'database.php';

// Conectarnos a la base de datos
ActiveRecord::setDB($db);

Y en la configuracion de la base de datos :

database.php 

<?php

$db = mysqli_connect(
  $_ENV['DB_HOST'],
  $_ENV['DB_USER'],
  $_ENV['DB_PASS'],
  $_ENV['DB_NAME']
);

$db->set_charset('utf8');

if (!$db) {
  echo "Error: No se pudo conectar a MySQL.";
  echo "errno de depuración: " . mysqli_connect_errno();
  echo "error de depuración: " . mysqli_connect_error();
  exit;
}

-> PUERTOS EMAIL;

EMAIL_HOST = smtp.mailtrap.io
EMAIL_PORT = 2525
EMAIL_USER = e8479d1f9f2131
EMAIL_PASS = c31ad6d59fe511

Es utilizado para los datos del servicio que nos estan ofreciendo los administradores de la base de datos.

Hay que tener una url de quien nos facilite para el envio de informacion atraves de smtp
APP_URL = http://localhost:3000

Para agregarlo en los archivo email.php 

<a href='" . $_ENV['APP_URL'] . " / -> El restante del codigo.

-> Rutas para Archivos Locales CSS y JS y creando un Build
Para hacer un codigo dinamico en JavaScript

En vez de utilizar localhost para hacerlo dinamico podemos utilizarlo 
const url = `${locatio.origin}/api/servicios`;

Si el proyecto queda hospedado junto al backend y el javascript en el mismo dominio:

const url = '/api/servicios';

Y como en nuestro caso, nos esta dando que la constante de la url sea /api/citas por ende quedara asi.

Ahora nos ubicamos en el archvio de Router.php
 public function comprobarRutas()
  {

    // Proteger Rutas...
    /* session_start(); */

    // Arreglo de rutas protegidas...
    // $rutas_protegidas = ['/admin', '/propiedades/crear', '/propiedades/actualizar', '/propiedades/eliminar', '/vendedores/crear', '/vendedores/actualizar', '/vendedores/eliminar'];

    // $auth = $_SESSION['login'] ?? null;

    $currentUrl = $_SERVER['PATH_INFO'] ?? '/'; -> Eliminamos esta linea
    $method = $_SERVER['REQUEST_METHOD'];

    if ($method === 'GET') {
      $fn = $this->getRoutes[$currentUrl] ?? null;
    } else {
      $fn = $this->postRoutes[$currentUrl] ?? null;
    }


    if ($fn) {
      // Call user fn va a llamar una función cuando no sabemos cual sera
      call_user_func($fn, $this); // This es para pasar argumentos
    } else {
      echo "Página No Encontrada o Ruta no válida";
    }
  }

Vamos a corregir unos errores principalmente

 public function comprobarRutas()
  {

    // Proteger Rutas...
    /* session_start(); */

    // Arreglo de rutas protegidas...
    // $rutas_protegidas = ['/admin', '/propiedades/crear', '/propiedades/actualizar', '/propiedades/eliminar', '/vendedores/crear', '/vendedores/actualizar', '/vendedores/eliminar'];

    // $auth = $_SESSION['login'] ?? null;

    $currentUrl = strtok($_SERVER['REQUEST_URI'], '?'); 
    Para que sirve strtok(); ?
    $method = $_SERVER['REQUEST_METHOD'];

    if ($method === 'GET') {
      $fn = $this->getRoutes[$currentUrl] ?? null;
    } else {
      $fn = $this->postRoutes[$currentUrl] ?? null;
    }


    if ($fn) {
      // Call user fn va a llamar una función cuando no sabemos cual sera
      call_user_func($fn, $this); // This es para pasar argumentos
    } else {
      echo "Página No Encontrada o Ruta no válida";
    }
  }

